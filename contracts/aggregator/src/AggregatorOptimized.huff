
#define function transfer(address,uint256) nonpayable returns ()
#define function approve(address,uint256) nonpayable returns ()

#define constant OWNER = FREE_STORAGE_POINTER()

#define macro NEXT() = takes (0) returns (0) {
dup1 0x00000600 eq uv3eops jumpi
dup1 0x00002000 eq uv3eopse jumpi
dup1 0x0000000e eq uv2eopse jumpi
dup1 0x0e000000 eq uv2eops jumpi
dup1 0x10000000 eq beops jumpi
dup1 0x20000000 eq beopse jumpi
dup1 0x00000080 eq ps jumpi
dup1 0x00000001 eq wd jumpi
dup1 0x00000002 eq ap jumpi
err jump
    uv3eops:
        dup2 0x04 add
        UV3EXACT_OUT_PAY_TO_SELF()
        0x00 0x00 return
    uv3eopse:
        dup2 0x04 add
        UV3EXACT_OUT_PAY_TO_SENDER()
        0x00 0x00 return

    uv2eopse:
        dup2 0x04 add
        UV2EXACT_OUT_PAY_TO_SENDER()
        0x00 0x00 return

    uv2eops:
        dup2 0x04 add
        UV2EXACT_OUT_PAY_TO_SELF()
        0x00 0x00 return

    beopse:
        dup2 0x04 add
        BALANCER_EXACT_OUT_PAY_TO_SENDER()
        0x00 0x00 return

    beops:
        dup2 0x04 add
        BALANCER_EXACT_OUT_PAY_TO_SELF()
        0x00 0x00 return

    ps:
        dup2 0x04 add
        PAY_SENDER()
        0x00 0x00 return
    wd:
        WITHDRAW()
        0x00 0x00 return

    ap:
        APPROVE()
        0x00 0x00 return


}

#define macro ONLY_OWNER() = takes (0) returns (0) {
    caller                   // [msg.sender]
    [OWNER] sload            // [owner, msg.sender]
    eq                       // [owner == msg.sender]
    is_owner jumpi           // []

    0x00 0x00 revert
    is_owner:
}

#define macro CONSTRUCTOR() = takes (0) returns (0) {
    caller
    [OWNER]                             // [OWNER, owner]
    sstore                              // []

}

#define macro SET_SQRT_PRICE() = takes (0) returns (0) {

    0x24 mload
    0x1 eq min jumpi
    max jumpi
    min:
        0x1000276A4
        0x64 mstore
        cont jumpi
    max:
        0xFFFD8963EFD1FC6A506488495D951D5263988D25
        0x64 mstore

    cont:

}

#define macro WITHDRAW() = takes (0) returns (0) {
    ONLY_OWNER()
    0x04 calldataload                                                   // [tokenAddress]
    0x24 calldataload                                                   // [amount, tokenAddress]
    __FUNC_SIG(transfer)                                                // [sig, amount, tokenAddress]

    0x00 mstore                                                         // [amount, tokenAddress]


    // store args in memory
    // address, uint256
    caller 0x20 mstore                                                  // [amount, tokenAddress]
    0x40 mstore                                                         // [tokenAddress]


    // make call. return size is zero because we can fetch it after the call
    0x00                        // [ret_size, stepOffset]
    dup1                        // [ret_offset, ret_size, stepOffset]
    0x44                        // [args_size, ret_offset, ret_size, stepOffset]
    0x1c                        // [args_offset, args_size, ret_offset, ret_size, stepOffset]
    dup3                        // [value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    dup6                        // [to, value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    gas                         // [gas, to, value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    call                        // [successs, stepOffset]

    iszero iszero               // [success, acct_addr, amount, getter_addr]
    transfer_success jumpi      // [acct_addr, amount, getter_addr]
    err jump

    // Resume execution in invoking macro
    transfer_success:
}

#define macro APPROVE() = takes (0) returns (0) {
    ONLY_OWNER()
    0x04 calldataload                                                   // [tokenAddress]
    0x24 calldataload                                                   // [to, tokenAddress]
    0x44 calldataload                                                   // [amount, to, tokenAddress]
    __FUNC_SIG(approve)                                                // [sig, amount, to, tokenAddress]

    0x00 mstore                                                         // [amount, to, tokenAddress]


    // store args in memory
    // address, uint256
    dup2 0x20 mstore                                                  // [amount, to, tokenAddress]
    0x40 mstore                                                         // [tokenAddress]


    // make call. return size is zero because we can fetch it after the call
    0x00                        // [ret_size, stepOffset]
    dup1                        // [ret_offset, ret_size, stepOffset]
    0x44                        // [args_size, ret_offset, ret_size, stepOffset]
    0x1c                        // [args_offset, args_size, ret_offset, ret_size, stepOffset]
    dup3                        // [value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    dup6                        // [to, value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    gas                         // [gas, to, value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    call                        // [successs, stepOffset]

    iszero iszero               // [success, acct_addr, amount, getter_addr]
    approve_success jumpi      // [acct_addr, amount, getter_addr]
    err jump

    // Resume execution in invoking macro
    approve_success:
}



#define macro PAY_SENDER() = takes (0) returns (0) {
    dup1 calldataload 0x60 shr                                      // [tokenAddress, stepOffset]
    dup2 0x14 add calldataload 0xF8 shr                                 // [amountSize, tokenAddress, stepOffset]
    dup3 0x15 add calldataload dup2 0x4 mul 0x100 sub shr               // [amount, amountSize, tokenAddress, stepOffset]
    __FUNC_SIG(transfer)                                                // [sig, amount, amountSize, tokenAddress, stepOffset]
    0x00 mstore                                                         // [amount, amountSize, tokenAddress, stepOffset]

    // store args in memory
    // address, uint256
    caller 0x20 mstore                                                  // [amount, amountSize, tokenAddress, stepOffset]
    0x40 mstore                                                         // [amountSize, tokenAddress, stepOffset]


    // make call. return size is zero because we can fetch it after the call
    0x00                        // [ret_size, stepOffset]
    dup1                        // [ret_offset, ret_size, stepOffset]
    0x44                        // [args_size, ret_offset, ret_size, stepOffset]
    0x1c                        // [args_offset, args_size, ret_offset, ret_size, stepOffset]
    dup3                        // [value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    dup7                        // [to, value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    gas                         // [gas, to, value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    call                        // [successs, stepOffset]

    iszero iszero
    transfer_success jumpi
    err jump

    // Resume execution in invoking macro
    transfer_success:
}


#define macro BALANCER_EXACT_OUT_PAY_TO_SENDER() = takes(0) returns(0) {
    0x52bbbe29 0xe0 shl 0x00 mstore
    dup1 calldataload                                                   // [poolId, stepOffset]
    dup2 0x20 add calldataload 0x60 shr                                 // [assetIn, poolId, stepOffset]
    dup3 0x34 add calldataload 0x60 shr                                 // [assetOut, assetIn, poolId, stepOffset]
    dup4 0x48 add calldataload 0xF8 shr                                 // [amountSize, assetOut, assetIn, poolId, stepOffset]
    dup5 0x49 add calldataload dup2 0x4 mul 0x100 sub shr               // [amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    dup6 0x49 add 0x2 dup4 div add calldataload 0xF8 shr                        // [limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    dup7 0x4A add 0x2 dup5 div add calldataload dup2 0x4 mul 0x100 sub shr      // [limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]

    0xe0 0x04 mstore                                                    // SingleSwap start

    // fund management
    address 0x24 mstore
    0x00 0x44 mstore
    caller 0x64 mstore
    0x00 0x84 mstore

    // limit
    dup1 0xA4 mstore

    // deadline
    0xFFFFFFFFFFFFFFFFFFFFFFFFFFF 0xC4 mstore

    //singleswap
    dup7 0xE4 mstore
    0x01 0x104 mstore
    dup6 0x124 mstore
    dup5 0x144 mstore
    dup3 0x164 mstore
    0xC0 0x184 mstore

    0x40                                                // [retSize, stepOffset]
    0x300                                               // [retOffset, retSize, stepOffset]
    0x1C4                                               // [argSize, retOffset, retSize, stepOffset]
    0x00                                                // [argOffset, argSize, retOffset, retSize, stepOffset]
    0x00                                                // [value, argOffset, argSize, retOffset, retSize, stepOffset]
    0xBA12222222228d8Ba445958a75a0704d566BF2C8          // [to, argOffset, argSize, retOffset, retSize, stepOffset]
    0x1388 gas sub
    call

    iszero iszero
    beopse_success jumpi
    err jump

    beopse_success:

}


#define macro BALANCER_EXACT_OUT_PAY_TO_SELF() = takes(0) returns(0) {
    0x52bbbe29 0xe0 shl 0x00 mstore

    dup1 calldataload                                                   // [poolId, stepOffset]
    dup2 0x20 add calldataload 0x60 shr                                 // [assetIn, poolId, stepOffset]
    dup3 0x34 add calldataload 0x60 shr                                 // [assetOut, assetIn, poolId, stepOffset]
    dup4 0x48 add calldataload 0xF8 shr                                 // [amountSize, assetOut, assetIn, poolId, stepOffset]
    dup5 0x49 add calldataload dup2 0x4 mul 0x100 sub shr               // [amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    dup6 0x49 add 0x2 dup4 div add calldataload 0xF8 shr                        // [limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    dup7 0x4A add 0x2 dup5 div add calldataload dup2 0x4 mul 0x100 sub shr      // [limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]

    0xe0 0x04 mstore                                                    // SingleSwap start

    // fund management
    address 0x24 mstore
    0x00 0x44 mstore
    caller 0x64 mstore
    0x00 0x84 mstore

    // limit
    dup1 0xA4 mstore

    // deadline
    0xFFFFFFFFFFFFFFFFFFFFFFFFFFF 0xC4 mstore

    //singleswap
    dup7 0xE4 mstore
    0x01 0x104 mstore
    dup6 0x124 mstore
    dup5 0x144 mstore
    dup3 0x164 mstore
    0xC0 0x184 mstore
    0x40                                                // [retSize, stepOffset]
    0x300                                               // [retOffset, retSize, stepOffset]
    0x1C4                                               // [argSize, retOffset, retSize, stepOffset]
    0x00                                                // [argOffset, argSize, retOffset, retSize, stepOffset]
    0x00                                                // [value, argOffset, argSize, retOffset, retSize, stepOffset]
    0xBA12222222228d8Ba445958a75a0704d566BF2C8          // [to, argOffset, argSize, retOffset, retSize, stepOffset]
    0x1388 gas sub
    call

    iszero iszero
    beops_success jumpi
    err jump

    beops_success:


}

#define macro UV3EXACT_OUT_PAY_TO_SELF() = takes (0) returns (0) {
    0x128acb08 0xe0 shl 0x00 mstore

    address 0x04 mstore

    dup1 calldataload 0xF8 shr                                          // [zeroForOne, stepOffset]
    dup2 0x1 add calldataload 0x60 shr                                  // [poolAddress, zeroForOne, stepOffset]
    dup3 0x15 add calldataload 0xF8 shr                                 // [amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x16 add calldataload dup2 0x4 mul 0x100 sub shr               // [amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x24 mstore                                                    // [amount, amountSize, poolAddress, zeroForOne, stepOffset]

    // amount should be negative for exact out
    0x00 sub
    dup1 0x44 mstore                                                    // [amount, amountSize, poolAddress, zeroForOne, stepOffset]

    dup5

    SET_SQRT_PRICE()

    dup5                                                                // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0xA0 0x84 mstore

    dup1 0x16 add 0x2 dup5 div add calldatasize sub                             // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1                                                                // [remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1 0xA4 mstore
    dup3 0x16 add 0x2 dup7 div add                                              // [stepOffset + dataUsed, remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0xC4 calldatacopy                                                   // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    // memory [functionSelector, recipient, zeroForOne, amount, sqrtPrice, dataLocation, data, poolAddress]
    0x40                                                  // [retSize, stepOffset]
    0x300                                               // [retOffset, retSize, stepOffset]
    dup3 0xC4 add                                       // [argSize, retOffset, retSize, stepOffset]
    0x00                                                // [argOffset, argSize, retOffset, retSize, stepOffset]
    0x00                                                // [value, argOffset, argSize, retOffset, retSize, stepOffset]
    dup10                                          // [to, argOffset, argSize, retOffset, retSize, stepOffset]
    0x1388 gas sub
    call
    iszero iszero
    uv3eops_success jumpi
    err jump

    // Resume execution in invoking macro
    uv3eops_success:

}
#define macro UV3EXACT_OUT_PAY_TO_SENDER() = takes (0) returns (0) {
    0x128acb08 0xe0 shl 0x00 mstore
    caller 0x04 mstore
    dup1 calldataload 0xF8 shr                                          // [zeroForOne, stepOffset]
    dup2 0x1 add calldataload 0x60 shr                                  // [poolAddress, zeroForOne, stepOffset]
    dup3 0x15 add calldataload 0xF8 shr                                 // [amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x16 add calldataload dup2 0x4 mul 0x100 sub shr               // [amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x24 mstore                                                    // [amount, amountSize, poolAddress, zeroForOne, stepOffset]
    // amount should be negative for exact out
    0x00 sub
    dup1 0x44 mstore                                                    // [amount, amountSize, poolAddress, zeroForOne, stepOffset]

    dup5
    SET_SQRT_PRICE()

    dup5                                                                // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0xA0 0x84 mstore

    dup1 0x16 add 0x2 dup5 div add calldatasize sub                            // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1                                                                // [remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1 0xA4 mstore
    dup3 0x16 add 0x2 dup7 div add                                      // [stepOffset + dataUsed, remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0xC4 calldatacopy                                                   // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    // memory [functionSelector, recipient, zeroForOne, amount, sqrtPrice, dataLocation, data, poolAddress]
    0x40                                                  // [retSize, stepOffset]
    0x300                                               // [retOffset, retSize, stepOffset]
    dup3 0xC4 add                                       // [argSize, retOffset, retSize, stepOffset]
    0x00                                                // [argOffset, argSize, retOffset, retSize, stepOffset]
    0x00                                                // [value, argOffset, argSize, retOffset, retSize, stepOffset]
    dup10                                          // [to, argOffset, argSize, retOffset, retSize, stepOffset]
    gas
    call
    iszero iszero
    uv3eopse_success jumpi
    err jump

    // Resume execution in invoking macro
    uv3eopse_success:


}

#define macro UV2EXACT_OUT_PAY_TO_SENDER() = takes (0) returns (0) {


    0x022c0d9f 0xe0 shl 0x00 mstore
    dup1 calldataload 0xF8 shr                                          // [zeroForOne, stepOffset]
    dup2 0x1 add calldataload 0x60 shr                                  // [debtToken, zeroForOne, stepOffset]
    dup3 0x15 add calldataload 0x60 shr                                 // [poolAddress, debtToken, zeroForOne, stepOffset]
    dup4 0x29 add calldataload 0xF8 shr                                 // [amountSize, poolAddress, debtToken zeroForOne, stepOffset]
    dup5 0x2A add calldataload dup2 0x4 mul 0x100 sub shr               // [amount, amountSize, poolAddress, debtToken, zeroForOne, stepOffset]
    dup5
    iszero _Zero_Token_out jumpi

        0x00 0x04 mstore
        dup1 0x24 mstore

        __Continue_Swap_Call jump
    _Zero_Token_out:

        dup1 0x04 mstore
        0x00 0x24 mstore

    __Continue_Swap_Call:

    address 0x44 mstore

    dup6                                                                    // [stepOffset, amount, amountSize, poolAddress, debtToken, zeroForOne, stepOffset]

    0x80 0x64 mstore

    dup1 0x2A add 0x2 dup5 div add calldatasize sub                            // [remainingData, stepOffset, amount, amountSize, poolAddress, debtToken, zeroForOne, stepOffset]

    dup1                                                                // [remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, debtToken, zeroForOne, stepOffset]
    dup1 0x84 mstore
    dup3 0x2A add 0x2 dup7 div add                                      // [stepOffset + dataUsed, remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, debtToken, zeroForOne, stepOffset]

    0xA4 calldatacopy                                                   // [remainingData, stepOffset, amount, amountSize, poolAddress, debtToken, zeroForOne, stepOffset]
    0x00                                                  // [retSize, stepOffset]
    0x00                                               // [retOffset, retSize, stepOffset]
    dup3 0xc4 add                                                // [argSize, retOffset, retSize, stepOffset]
    0x00                                                // [argOffset, argSize, retOffset, retSize, stepOffset]
    0x00                                                // [value, argOffset, argSize, retOffset, retSize, stepOffset]
    dup10                                          // [to, argOffset, argSize, retOffset, retSize, stepOffset]
    0x1388 gas sub
    call



    iszero iszero transfer_step jumpi
    err jump


    // store args in memory
    // address, uint256
    transfer_step:

    __FUNC_SIG(transfer)           // [sig, remainingData, stepOffset, amount, amountSize, poolAddress, debtToken, zeroForOne, stepOffset]
    0x00 mstore                    // [remainingData, stepOffset, amount, amountSize, poolAddress, debtToken, zeroForOne, stepOffset]
    caller 0x20 mstore
    dup3 0x40 mstore


    0x00                        // [ret_size, stepOffset]
    dup1                        // [ret_offset, ret_size, stepOffset]
    0x44                        // [args_size, ret_offset, ret_size, stepOffset]
    0x1c                        // [args_offset, args_size, ret_offset, ret_size, stepOffset]
    dup3                        // [value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    dup11                       // [to, value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    gas                         // [gas, to, value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    call                        // [successs, stepOffset]

    iszero iszero
    uv2eopse_success jumpi
    err jump

    // Resume execution in invoking macro
    uv2eopse_success:


}

#define macro UV2EXACT_OUT_PAY_TO_SELF() = takes (0) returns (0) {
    0x022c0d9f 0xe0 shl 0x00 mstore
    dup1 calldataload 0xF8 shr                                          // [zeroForOne, stepOffset]
    dup2 0x1 add calldataload 0x60 shr                                  // [poolAddress, zeroForOne, stepOffset]
    dup3 0x15 add calldataload 0xF8 shr                                 // [amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x16 add calldataload dup2 0x4 mul 0x100 sub shr               // [amount, amountSize, poolAddress, zeroForOne, stepOffset]

    dup4
    iszero _Zero_Token_out jumpi
        0x00 0x04 mstore
        dup1 0x24 mstore
        __Continue_Swap_Call jump
    _Zero_Token_out:
        dup1 0x04 mstore
        0x00 0x24 mstore

    __Continue_Swap_Call:

    address 0x44 mstore
    dup5                                                                    // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    0x80 0x64 mstore

    dup1 0x16 add 0x2 dup5 div add calldatasize sub                            // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    dup1                                                                // [remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1 0x84 mstore
    dup3 0x16 add 0x2 dup7 div add                                      // [stepOffset + dataUsed, remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0xA4 calldatacopy                                                   // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    0x00                                                  // [retSize, stepOffset]
    0x00                                               // [retOffset, retSize, stepOffset]
    dup3 0xC4 add                                       // [argSize, retOffset, retSize, stepOffset]
    0x00                                                // [argOffset, argSize, retOffset, retSize, stepOffset]
    0x00                                                // [value, argOffset, argSize, retOffset, retSize, stepOffset]
    dup10                                          // [to, argOffset, argSize, retOffset, retSize, stepOffset]
    0x1388 gas sub
    call

    iszero iszero
    uv2eops_success jumpi
    err jump
    // Resume execution in invoking macro
    uv2eops_success:

}

#define macro V3_CALLBACK() = takes (0) returns (0) {
    0x84                // data start offset
    0x84 calldataload
    0xE0 shr
    NEXT()
}

#define macro V2_CALLBACK() = takes (0) returns (0) {
    0xA4                // data start offset
    0xA4 calldataload
    0xE0 shr
    NEXT()
}

#define macro REVERT() = takes(0) returns (0) {
    0x00 0x00 revert
}
#define macro MAIN() = takes (0) returns (0) {


    0x00                    // signifies first place
    0x00 calldataload        // [calldata @ 0x00, 0x48]

    0xE0 shr                 // [func_sig (calldata @ 0x00 >> 0xE0), 0x48]

    dup1 0xfa461e33 eq v3Callback jumpi
    dup1 0x10d1e85c eq v2Callback jumpi
    // solidly
    dup1 0x9a7bff79 eq v2Callback jumpi
    //pancake
    dup1 0x84800812 eq v2Callback jumpi

    NEXT()
    stop
    v3Callback:
        V3_CALLBACK()
        end jump

    v2Callback:
        V2_CALLBACK()
        end jump

    err:
        REVERT()
        stop
    end:
}
