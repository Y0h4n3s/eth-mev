
#define function transfer(address,uint256) nonpayable returns ()
#define function approve(address,uint256) nonpayable returns ()
#define constant OWNER = FREE_STORAGE_POINTER()



#define macro ONLY_OWNER() = takes (0) returns (0) {
    caller                   // [msg.sender]
    [OWNER] sload            // [owner, msg.sender]
    eq                       // [owner == msg.sender]
    is_owner jumpi           // []

    0x00 0x00 revert
    is_owner:
}

#define macro CONSTRUCTOR() = takes (0) returns (0) {
    caller
    [OWNER]                             // [OWNER, owner]
    sstore                              // []

}

#define macro SET_SQRT_PRICE() = takes (0) returns (0) {

    0x24 mload
    0x1 eq min jumpi
    max jumpi
    min:
        0x1000276A4
        0x64 mstore
        cont jumpi
    max:
        0xFFFD8963EFD1FC6A506488495D951D5263988D25
        0x64 mstore

    cont:

}

#define macro WITHDRAW() = takes (0) returns (0) {
    ONLY_OWNER()
    0x04 calldataload                                                   // [tokenAddress]
    0x24 calldataload                                                   // [amount, tokenAddress]
    0xa9059cbb                                                // [sig, amount, tokenAddress]

    0x00 mstore                                                         // [amount, tokenAddress]


    // store args in memory
    // address, uint256
    caller 0x20 mstore                                                  // [amount, tokenAddress]
    0x40 mstore                                                         // [tokenAddress]


    // make call. return size is zero because we can fetch it after the call
    0x00                        // [ret_size, stepOffset]
    dup1                        // [ret_offset, ret_size, stepOffset]
    0x44                        // [args_size, ret_offset, ret_size, stepOffset]
    0x1c                        // [args_offset, args_size, ret_offset, ret_size, stepOffset]
    dup3                        // [value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    dup6                        // [to, value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    gas                         // [gas, to, value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    call                        // [successs, stepOffset]

    iszero iszero               // [success, acct_addr, amount, getter_addr]
    transfer_success jumpi      // [acct_addr, amount, getter_addr]
    err jump

    // Resume execution in invoking macro
    transfer_success:
}

#define macro APPROVE() = takes (0) returns (0) {
    ONLY_OWNER()
    0x04 calldataload                                                   // [tokenAddress]
    0x24 calldataload                                                   // [to, tokenAddress]
    0x44 calldataload                                                   // [amount, to, tokenAddress]
    __FUNC_SIG(approve)                                                // [sig, amount, to, tokenAddress]

    0x00 mstore                                                         // [amount, to, tokenAddress]


    // store args in memory
    // address, uint256
    dup2 0x20 mstore                                                  // [amount, to, tokenAddress]
    0x40 mstore                                                         // [tokenAddress]


    // make call. return size is zero because we can fetch it after the call
    0x00                        // [ret_size, stepOffset]
    dup1                        // [ret_offset, ret_size, stepOffset]
    0x44                        // [args_size, ret_offset, ret_size, stepOffset]
    0x1c                        // [args_offset, args_size, ret_offset, ret_size, stepOffset]
    dup3                        // [value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    dup6                        // [to, value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    gas                         // [gas, to, value, args_offset, args_size, ret_offset, ret_size, stepOffset]
    call                        // [successs, stepOffset]

    iszero iszero               // [success, acct_addr, amount, getter_addr]
    approve_success jumpi      // [acct_addr, amount, getter_addr]
    err jump

    // Resume execution in invoking macro
    approve_success:
}


#define macro PAY_BRIBE() = takes (0) returns (0) {
    // make call. return size is zero because we can fetch it after the call
    0x00                        // [ret_size]
    dup1                        // [ret_offset, ret_size]
    dup1                        // [args_size, ret_offset, ret_size]
    dup1                        // [args_offset, args_size, ret_offset, ret_size]
    callvalue                   // [value, args_offset, args_size, ret_offset, ret_size]
    coinbase                    // [to, value, args_offset, args_size, ret_offset, ret_size]
    gas                         // [gas, to, value, args_offset, args_size, ret_offset, ret_size]
    call                        // [successs, stepOffset]

    iszero iszero
    pb_transfer_success jumpi
    err jump

    // Resume execution in invoking macro
    pb_transfer_success:

    // [stepOffset]
    dup1 calldataload
    0xE0 shr
    dup1 0x0 eq end jumpi
    nxt jump
}



#define macro PAY_SENDER() = takes (0) returns (0) {
    0xa9059cbb 0x00 mstore
    dup1 calldataload 0x60 shr                                  // [tokenAddress, stepOffset]
    dup2 0x14 add calldataload 0xF8 shr                         // [amountSize, tokenAddress, stepOffset]
    dup3 0x15 add calldataload dup2 0x4 mul 0x100 sub shr       // [amount, amountSize, tokenAddress, stepOffset]

    caller 0x20 mstore                                          // [amount, amountSize, tokenAddress, stepOffset]
    0x40 mstore                                                 // [amountSize, tokenAddress, stepOffset]


    // make call. return size is zero because we can fetch it after the call
    0x00                        // [ret_size]
    dup1                        // [ret_offset, ret_size]
    0x44                        // [args_size, ret_offset, ret_size]
    0x1c                        // [args_offset, args_size, ret_offset, ret_size]
    dup3                        // [value, args_offset, args_size, ret_offset, ret_size]
    dup7                        // [to, value, args_offset, args_size, ret_offset, ret_size]
    gas                         // [gas, to, value, args_offset, args_size, ret_offset, ret_size]
    call                        // [successs, amountSize, tokenAddress, stepOffset]

    iszero iszero
    ps_transfer_success jumpi
    err jump

    // Resume execution in invoking macro
    ps_transfer_success:

    // [amountSize, tokenAddress, stepOffset]
    0x2 dup2 div dup4 add 0x15 add          // [nextStepOffset, amountSize, tokenAddress, stepOffset]
    swap3                                   // [stepOffset, tokenAddress, tokenAddress, nextStepOffset]
    pop pop pop                             // [nextStepOffset]
    dup1 calldataload
    0xE0 shr
    dup1 0x0 eq end jumpi
    nxt jump
}


#define macro PAY_NEXT() = takes (0) returns (0) {
    0xa9059cbb 0x00 mstore
    dup1 calldataload 0x60 shr                                  // [tokenAddress, stepOffset]
    dup2 0x14 add calldataload 0xF8 shr                         // [amountSize, tokenAddress, stepOffset]
    dup3 0x15 add calldataload dup2 0x4 mul 0x100 sub shr       // [amount, amountSize, tokenAddress, stepOffset]

    dup4 0x15 add 0x2 dup4 div add 0x4 add calldataload 0x60 shr    // [nextPool, amount, amountSize, tokenAddress, stepOffset]
    0x20 mstore                                                     // [amount, amountSize, tokenAddress, stepOffset]
    0x40 mstore                                                     // [amountSize, tokenAddress, stepOffset]


    // make call. return size is zero because we can fetch it after the call
    0x00                        // [ret_size]
    dup1                        // [ret_offset, ret_size]
    0x44                        // [args_size, ret_offset, ret_size]
    0x1c                        // [args_offset, args_size, ret_offset, ret_size]
    dup3                        // [value, args_offset, args_size, ret_offset, ret_size]
    dup7                        // [to, value, args_offset, args_size, ret_offset, ret_size]
    gas                         // [gas, to, value, args_offset, args_size, ret_offset, ret_size]
    call                        // [successs, amountSize, tokenAddress, stepOffset]

    iszero iszero
    pn_transfer_success jumpi
    err jump

    // Resume execution in invoking macro
    pn_transfer_success:

    // [amountSize, tokenAddress, stepOffset]
    0x2 dup2 div dup4 add 0x15 add          // [nextStepOffset, amountSize, tokenAddress, stepOffset]
    swap3                                   // [stepOffset, tokenAddress, tokenAddress, nextStepOffset]
    pop pop pop                             // [nextStepOffset]
    dup1 calldataload
    0xE0 shr
    dup1 0x0 eq end jumpi
    nxt jump
}

#define macro PAY_ADDRESS() = takes (0) returns (0) {
    0xa9059cbb 0x00 mstore
    dup1 calldataload 0x60 shr                                  // [tokenAddress, stepOffset]


    dup3 0x14 add calldataload 0x60 shr                         // [payToAddress, tokenAddress, stepOffset]
    0x20 mstore                                                 // [tokenAddress, stepOffset]

    dup2 0x28 add calldataload 0xF8 shr                         // [amountSize, tokenAddress, stepOffset]
    dup3 0x29 add calldataload dup2 0x4 mul 0x100 sub shr       // [amount, amountSize, tokenAddress, stepOffset]
    0x00 mstore                                                 // [amount, amountSize, tokenAddress, stepOffset]

    0x40 mstore                                                 // [amountSize, tokenAddress, stepOffset]


    // make call. return size is zero because we can fetch it after the call
    0x00                        // [ret_size]
    dup1                        // [ret_offset, ret_size]
    0x44                        // [args_size, ret_offset, ret_size]
    0x1c                        // [args_offset, args_size, ret_offset, ret_size]
    dup3                        // [value, args_offset, args_size, ret_offset, ret_size]
    dup7                        // [to, value, args_offset, args_size, ret_offset, ret_size]
    gas                         // [gas, to, value, args_offset, args_size, ret_offset, ret_size]
    call                        // [successs, amountSize, tokenAddress, stepOffset]

    iszero iszero
    pa_transfer_success jumpi
    err jump

    // Resume execution in invoking macro
    pa_transfer_success:

    // [amountSize, tokenAddress, stepOffset]
    0x2 dup2 div dup4 add 0x29 add          // [nextStepOffset, amountSize, tokenAddress, stepOffset]
    swap3                                   // [stepOffset, tokenAddress, tokenAddress, nextStepOffset]
    pop pop pop                             // [nextStepOffset]
    dup1 calldataload
    0xE0 shr
    dup1 0x0 eq end jumpi
    nxt jump
}


#define macro BALANCER_EXACT_OUT_PAY_TO_SENDER() = takes(0) returns(0) {
    0x52bbbe29 0xe0 shl 0x00 mstore
    dup1 calldataload                                                   // [poolId, stepOffset]
    dup2 0x20 add calldataload 0x60 shr                                 // [assetIn, poolId, stepOffset]
    dup3 0x34 add calldataload 0x60 shr                                 // [assetOut, assetIn, poolId, stepOffset]
    dup4 0x48 add calldataload 0xF8 shr                                 // [amountSize, assetOut, assetIn, poolId, stepOffset]
    dup5 0x49 add calldataload dup2 0x4 mul 0x100 sub shr               // [amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    dup6 0x49 add 0x2 dup4 div add calldataload 0xF8 shr                        // [limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    dup7 0x4A add 0x2 dup5 div add calldataload dup2 0x4 mul 0x100 sub shr      // [limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]

    0xe0 0x04 mstore                                                    // SingleSwap start

    // fund management
    address 0x24 mstore
    0x00 0x44 mstore
    caller 0x64 mstore
    0x00 0x84 mstore

    // limit
    dup1 0xA4 mstore

    // deadline
    0xFFFFFFFFFFFFFF 0xC4 mstore

    //singleswap
    dup7 0xE4 mstore
    0x01 0x104 mstore
    dup6 0x124 mstore
    dup5 0x144 mstore
    dup3 0x164 mstore
    0xC0 0x184 mstore

    0x40                                                // [retSize]
    0x300                                               // [retOffset, retSize]
    0x1C4                                               // [argSize, retOffset, retSize]
    0x00                                                // [argOffset, argSize, retOffset, retSize]
    0x00                                                // [value, argOffset, argSize, retOffset, retSize]
    0xBA12222222228d8Ba445958a75a0704d566BF2C8          // [to, argOffset, argSize, retOffset, retSize]
    0x1388 gas sub
    call

    iszero iszero
    beopse_success jumpi
    err jump

    // [limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    beopse_success:
    dup8 0x4A add 0x2 dup6 div add 0x2 dup3 div add         // [nextStepOffset, limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    swap8                                                   // [limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset, nextStepOffset]
    pop pop pop pop pop pop pop pop                         // [nextStepOffset]
    dup1 calldataload
    0xE0 shr
    dup1 0x0 eq end jumpi
    nxt jump
}


#define macro BALANCER_EXACT_OUT_PAY_TO_SELF() = takes(0) returns(0) {
    0x52bbbe29 0xe0 shl 0x00 mstore

    dup1 calldataload                                                   // [poolId, stepOffset]
    dup2 0x20 add calldataload 0x60 shr                                 // [assetIn, poolId, stepOffset]
    dup3 0x34 add calldataload 0x60 shr                                 // [assetOut, assetIn, poolId, stepOffset]
    dup4 0x48 add calldataload 0xF8 shr                                 // [amountSize, assetOut, assetIn, poolId, stepOffset]
    dup5 0x49 add calldataload dup2 0x4 mul 0x100 sub shr               // [amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    dup6 0x49 add 0x2 dup4 div add calldataload 0xF8 shr                        // [limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    dup7 0x4A add 0x2 dup5 div add calldataload dup2 0x4 mul 0x100 sub shr      // [limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]

    0xe0 0x04 mstore                                                    // SingleSwap start

    // fund management
    address 0x24 mstore
    0x00 0x44 mstore
    address 0x64 mstore
    0x00 0x84 mstore

    // limit
    dup1 0xA4 mstore

    // deadline
    0xFFFFFFFFFFFFFF 0xC4 mstore

    //singleswap
    dup7 0xE4 mstore
    0x01 0x104 mstore
    dup6 0x124 mstore
    dup5 0x144 mstore
    dup3 0x164 mstore
    0xC0 0x184 mstore
    0x40                                                // [retSize]
    0x300                                               // [retOffset, retSize]
    0x1C4                                               // [argSize, retOffset, retSize]
    0x00                                                // [argOffset, argSize, retOffset, retSize]
    0x00                                                // [value, argOffset, argSize, retOffset, retSize]
    0xBA12222222228d8Ba445958a75a0704d566BF2C8          // [to, value, argOffset, argSize, retOffset, retSize]
    0x1388 gas sub
    call

    iszero iszero
    beops_success jumpi
    err jump

    // [limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    beops_success:
    dup8 0x4A add 0x2 dup6 div add 0x2 dup3 div add         // [nextStepOffset, limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    swap8                                                   // [limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset, nextStepOffset]
    pop pop pop pop pop pop pop pop                         // [nextStepOffset]
    dup1 calldataload
    0xE0 shr
    dup1 0x0 eq end jumpi
    nxt jump

}



#define macro BALANCER_EXACT_OUT_PAY_TO_NEXT() = takes(0) returns(0) {
    0x52bbbe29 0xe0 shl 0x00 mstore

    dup1 calldataload                                                   // [poolId, stepOffset]
    dup2 0x20 add calldataload 0x60 shr                                 // [assetIn, poolId, stepOffset]
    dup3 0x34 add calldataload 0x60 shr                                 // [assetOut, assetIn, poolId, stepOffset]
    dup4 0x48 add calldataload 0xF8 shr                                 // [amountSize, assetOut, assetIn, poolId, stepOffset]
    dup5 0x49 add calldataload dup2 0x4 mul 0x100 sub shr               // [amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    dup6 0x49 add 0x2 dup4 div add calldataload 0xF8 shr                        // [limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    dup7 0x4A add 0x2 dup5 div add calldataload dup2 0x4 mul 0x100 sub shr      // [limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]

    0xe0 0x04 mstore                                                    // SingleSwap start

    // fund management
    address 0x24 mstore
    0x00 0x44 mstore

    dup8 0x4A add 0x2 dup6 div add 0x2 dup3 div add 0x4 add calldataload 0x60 shr  // [nextPool, limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    0x64 mstore
    0x00 0x84 mstore

    // limit
    dup1 0xA4 mstore

    // deadline
    0xFFFFFFFFFFFFFF 0xC4 mstore

    //singleswap
    dup7 0xE4 mstore
    0x01 0x104 mstore
    dup6 0x124 mstore
    dup5 0x144 mstore
    dup3 0x164 mstore
    0xC0 0x184 mstore
    0x40                                                // [retSize]
    0x300                                               // [retOffset, retSize]
    0x1C4                                               // [argSize, retOffset, retSize]
    0x00                                                // [argOffset, argSize, retOffset, retSize]
    0x00                                                // [value, argOffset, argSize, retOffset, retSize]
    0xBA12222222228d8Ba445958a75a0704d566BF2C8          // [to, value, argOffset, argSize, retOffset, retSize]
    0x1388 gas sub
    call

    iszero iszero beopn_success jumpi
    err jump

    // [limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    beopn_success:
    dup8 0x4A add 0x2 dup6 div add 0x2 dup3 div add         // [nextStepOffset, limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    swap8                                                   // [limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset, nextStepOffset]
    pop pop pop pop pop pop pop pop                         // [nextStepOffset]
    dup1 calldataload
    0xE0 shr
    dup1 0x0 eq end jumpi
    nxt jump

}



#define macro BALANCER_EXACT_OUT_PAY_TO_ADDRESS() = takes(0) returns(0) {
    0x52bbbe29 0xe0 shl 0x00 mstore

    dup1 calldataload                                                   // [poolId, stepOffset]

    dup2 0x20 add calldataload 0x60 shr                                 // [payToAddress, poolId, stepOffset]
    0x64 mstore                                                         // [poolId, stepOffset]

    dup2 0x34 add calldataload 0x60 shr                                 // [assetIn, poolId, stepOffset]
    dup3 0x48 add calldataload 0x60 shr                                 // [assetOut, assetIn, poolId, stepOffset]
    dup4 0x5C add calldataload 0xF8 shr                                 // [amountSize, assetOut, assetIn, poolId, stepOffset]
    dup5 0x5D add calldataload dup2 0x4 mul 0x100 sub shr               // [amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    dup6 0x5D add 0x2 dup4 div add calldataload 0xF8 shr                        // [limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    dup7 0x5E add 0x2 dup5 div add calldataload dup2 0x4 mul 0x100 sub shr      // [limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]

    0xe0 0x04 mstore                                                    // SingleSwap start

    // fund management
    address 0x24 mstore
    0x00 0x44 mstore
    0x00 0x84 mstore

    // limit
    dup1 0xA4 mstore

    // deadline
    0xFFFFFFFFFFFFFF 0xC4 mstore

    //singleswap
    dup7 0xE4 mstore
    0x01 0x104 mstore
    dup6 0x124 mstore
    dup5 0x144 mstore
    dup3 0x164 mstore
    0xC0 0x184 mstore
    0x40                                                // [retSize]
    0x300                                               // [retOffset, retSize]
    0x1C4                                               // [argSize, retOffset, retSize]
    0x00                                                // [argOffset, argSize, retOffset, retSize]
    0x00                                                // [value, argOffset, argSize, retOffset, retSize]
    0xBA12222222228d8Ba445958a75a0704d566BF2C8          // [to, value, argOffset, argSize, retOffset, retSize]
    0x1388 gas sub
    call

    iszero iszero beopa_success jumpi
    err jump

    // [limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    beopa_success:
    dup8 0x5E add 0x2 dup6 div add 0x2 dup3 div add         // [nextStepOffset, limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset]
    swap8                                                   // [limit, limitSize, amount, amountSize, assetOut, assetIn, poolId, stepOffset, nextStepOffset]
    pop pop pop pop pop pop pop pop                         // [nextStepOffset]
    dup1 calldataload
    0xE0 shr
    dup1 0x0 eq end jumpi
    nxt jump

}


#define macro UV3EXACT_OUT_PAY_TO_SELF() = takes (0) returns (0) {
    0x128acb08 0xe0 shl 0x00 mstore

    address 0x04 mstore

    dup1 calldataload 0x60 shr                                      // [poolAddress, stepOffset]
    dup2 0x14 add calldataload 0xF8 shr                             // [zeroForOne, poolAddress, stepOffset]
    swap1
    dup3 0x15 add calldataload 0xF8 shr                             // [amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x16 add calldataload dup2 0x4 mul 0x100 sub shr           // [amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x24 mstore                                                // [amount, amountSize, poolAddress, zeroForOne, stepOffset]

    // amount should be negative for exact out
    0x00 sub
    dup1 0x44 mstore                                                // [amount, amountSize, poolAddress, zeroForOne, stepOffset]

    dup5

    SET_SQRT_PRICE()

    dup5                                                            // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0xA0 0x84 mstore

    dup1 0x16 add 0x2 dup5 div add calldatasize sub                 // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1                                                            // [remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1 0xA4 mstore
    dup3 0x16 add 0x2 dup7 div add                                  // [stepOffset + dataUsed, remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    0xC4 calldatacopy                                               // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    // memory [functionSelector, recipient, zeroForOne, amount, sqrtPrice, dataLocation, data, poolAddress]
    0x40                 // [retSize]
    0x300                // [retOffset, retSize]
    dup3 0xC4 add        // [argSize, retOffset, retSize]
    0x00                 // [argOffset, argSize, retOffset, retSize]
    0x00                 // [value, argOffset, argSize, retOffset, retSize]
    dup10                // [to, value, argOffset, argSize, retOffset, retSize]
    0x1388 gas sub
    call

    iszero iszero uv3eops_success jumpi
    err jump

    // Resume execution in invoking macro
    uv3eops_success:

}
#define macro UV3EXACT_OUT_PAY_TO_SENDER() = takes (0) returns (0) {
    0x128acb08 0xe0 shl 0x00 mstore
    caller 0x04 mstore
    dup1 calldataload 0x60 shr                                          // [poolAddress, stepOffset]
    dup2 0x14 add calldataload 0xF8 shr                                 // [zeroForOne, poolAddress, stepOffset]
    swap1
    dup3 0x15 add calldataload 0xF8 shr                                 // [amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x16 add calldataload dup2 0x4 mul 0x100 sub shr               // [amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x24 mstore                                                    // [amount, amountSize, poolAddress, zeroForOne, stepOffset]
    // amount should be negative for exact out
    0x00 sub
    dup1 0x44 mstore                                                    // [amount, amountSize, poolAddress, zeroForOne, stepOffset]

    dup5
    SET_SQRT_PRICE()

    dup5                                                                // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0xA0 0x84 mstore

    dup1 0x16 add 0x2 dup5 div add calldatasize sub                     // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1                                                                // [remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1 0xA4 mstore
    dup3 0x16 add 0x2 dup7 div add                                      // [stepOffset + dataUsed, remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0xC4 calldatacopy                                                   // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    // memory [functionSelector, recipient, zeroForOne, amount, sqrtPrice, dataLocation, data, poolAddress]
    0x40                   // [retSize]
    0x300                  // [retOffset, retSize]
    dup3 0xC4 add          // [argSize, retOffset, retSize]
    0x00                   // [argOffset, argSize, retOffset, retSize]
    0x00                   // [value, argOffset, argSize, retOffset, retSize]
    dup10                  // [to, value, argOffset, argSize, retOffset, retSize]
    gas
    call
    iszero iszero
    uv3eopse_success jumpi
    err jump

    // Resume execution in invoking macro
    uv3eopse_success:


}


#define macro UV3EXACT_OUT_PAY_TO_NEXT() = takes (0) returns (0) {
    0x128acb08 0xe0 shl 0x00 mstore
    dup1 calldataload 0x60 shr                                          // [poolAddress, stepOffset]
    dup2 0x14 add calldataload 0xF8 shr                                 // [zeroForOne, poolAddress, stepOffset]
    swap1
    dup3 0x15 add calldataload 0xF8 shr                                 // [amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x16 add calldataload dup2 0x4 mul 0x100 sub shr               // [amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x24 mstore                                                    // [amount, amountSize, poolAddress, zeroForOne, stepOffset]
    // amount should be negative for exact out
    0x00 sub
    dup1 0x44 mstore                                                    // [amount, amountSize, poolAddress, zeroForOne, stepOffset]

    dup5
    SET_SQRT_PRICE()

    dup5                                                                // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1 0x16 add 0x2 dup5 div add 0x4 add calldataload 0x60 shr        // [nextPool, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    0x04 mstore                                                         // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    0xA0 0x84 mstore

    dup1 0x16 add 0x2 dup5 div add calldatasize sub                     // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1                                                                // [remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1 0xA4 mstore
    dup3 0x16 add 0x2 dup7 div add                                      // [stepOffset + dataUsed, remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0xC4 calldatacopy                                                   // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    // memory [functionSelector, recipient, zeroForOne, amount, sqrtPrice, dataLocation, data, poolAddress]
    0x40                // [retSize]
    0x300               // [retOffset, retSize]
    dup3 0xC4 add       // [argSize, retOffset, retSize]
    0x00                // [argOffset, argSize, retOffset, retSize]
    0x00                // [value, argOffset, argSize, retOffset, retSize]
    dup10               // [to, value, argOffset, argSize, retOffset, retSize]
    gas
    call
    iszero iszero
    uv3eopse_success jumpi
    err jump

    // Resume execution in invoking macro
    uv3eopse_success:


}


#define macro UV3EXACT_OUT_PAY_TO_ADDRESS() = takes (0) returns (0) {
    0x128acb08 0xe0 shl 0x00 mstore
    dup1 calldataload 0x60 shr                                          // [poolAddress, stepOffset]
    dup2 0x14 add calldataload 0xF8 shr                                 // [zeroForOne, poolAddress, stepOffset]
    swap1

    dup3 0x15 add calldataload 0x60 shr                                 // [payToAddress, poolAddress, zeroForOne, stepOffset]
    0x04 mstore                                                         // [poolAddress, zeroForOne, stepOffset]

    dup4 0x29 add calldataload 0xF8 shr                                 // [amountSize, poolAddress, zeroForOne, stepOffset]
    dup5 0x2A add calldataload dup2 0x4 mul 0x100 sub shr               // [amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup6 0x24 mstore                                                    // [amount, amountSize, poolAddress, zeroForOne, stepOffset]
    // amount should be negative for exact out
    0x00 sub
    dup1 0x44 mstore                                                    // [amount, amountSize, poolAddress, zeroForOne, stepOffset]

    dup5
    SET_SQRT_PRICE()

    dup5                                                                // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    0xA0 0x84 mstore

    dup1 0x2A add 0x2 dup5 div add calldatasize sub                     // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1                                                                // [remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1 0xA4 mstore
    dup3 0x2A add 0x2 dup7 div add                                      // [stepOffset + dataUsed, remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0xC4 calldatacopy                                                   // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    // memory [functionSelector, recipient, zeroForOne, amount, sqrtPrice, dataLocation, data, poolAddress]
    0x40                // [retSize]
    0x300               // [retOffset, retSize]
    dup3 0xC4 add       // [argSize, retOffset, retSize]
    0x00                // [argOffset, argSize, retOffset, retSize]
    0x00                // [value, argOffset, argSize, retOffset, retSize]
    dup10               // [to, value, argOffset, argSize, retOffset, retSize]
    gas
    call
    iszero iszero
    uv3eopse_success jumpi
    err jump

    // Resume execution in invoking macro
    uv3eopse_success:


}

#define macro UV2EXACT_OUT_PAY_TO_SENDER_INLINE() = takes (0) returns (0) {

    0x022c0d9f 0xe0 shl 0x00 mstore
    dup1 calldataload 0x60 shr                                          // [poolAddress, stepOffset]
    dup2 0x14 add calldataload 0xF8 shr                                 // [zeroForOne, poolAddress, stepOffset]
    swap1
    dup3 0x15 add calldataload 0xF8 shr                                 // [amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x16 add calldataload dup2 0x4 mul 0x100 sub shr               // [amount, amountSize, poolAddress, zeroForOne, stepOffset]

    dup4
    iszero uv2eopsei_Zero_Token_out jumpi

        0x00 0x04 mstore
        dup1 0x24 mstore
        uv2eopsei_cont jump
    uv2eopsei_Zero_Token_out:
        dup1 0x04 mstore
        0x00 0x24 mstore

    uv2eopsei_cont:
    caller 0x44 mstore

    dup5                            // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0x80 0x64 mstore                // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    0x00                            // [retSize]
    0x00                            // [retOffset, retSize]
    0xc4                            // [argSize, retOffset, retSize]
    0x00                            // [argOffset, argSize, retOffset, retSize]
    0x00                            // [value, argOffset, argSize, retOffset, retSize]
    dup9                            // [to, argOffset, argSize, retOffset, retSize]
    0x1388 gas sub
    call



    iszero iszero uv2eopsei_success jumpi
    err jump

    // Resume execution in invoking macro
    // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    uv2eopsei_success:
    0x2 dup4 div dup2 add 0x16 add      // [nextStepOffset, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    swap6                               // [stepOffset, stepOffset, amount, amountSize, poolAddress, zeroForOne, nextStepOffset]
    pop pop pop pop pop pop             // [nextStepOffset]
    dup1 calldataload
    0xE0 shr
    dup1 0x0 eq end jumpi
    nxt jump
}


#define macro UV2EXACT_OUT_PAY_TO_SENDER() = takes (0) returns (0) {


    0x022c0d9f 0xe0 shl 0x00 mstore

    dup1 calldataload 0x60 shr                                  // [poolAddress, stepOffset]
    dup2 0x14 add calldataload 0xF8 shr                         // [zeroForOne, poolAddress, stepOffset]
    swap1
    dup3 0x15 add calldataload 0x60 shr                         // [poolAddress, debtToken, zeroForOne, stepOffset]
    dup4 0x29 add calldataload 0xF8 shr                         // [amountSize, poolAddress, debtToken zeroForOne, stepOffset]
    dup5 0x2A add calldataload dup2 0x4 mul 0x100 sub shr       // [amount, amountSize, poolAddress, debtToken, zeroForOne, stepOffset]
    dup5

    iszero uv2eopse_Zero_Token_out jumpi
        0x00 0x04 mstore
        dup1 0x24 mstore
        uv2eopse_cont jump
    uv2eopse_Zero_Token_out:
        dup1 0x04 mstore
        0x00 0x24 mstore
        uv2eopse_cont:

    address 0x44 mstore
    dup6                                                    // [stepOffset, amount, amountSize, poolAddress, debtToken, zeroForOne, stepOffset]
    0x80 0x64 mstore
    dup1 0x2A add 0x2 dup5 div add calldatasize sub         // [remainingData, stepOffset, amount, amountSize, poolAddress, debtToken, zeroForOne, stepOffset]
    dup1                                                    // [remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, debtToken, zeroForOne, stepOffset]
    dup1 0x84 mstore
    dup3 0x2A add 0x2 dup7 div add                          // [stepOffset + dataUsed, remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, debtToken, zeroForOne, stepOffset]
    0xA4 calldatacopy                                       // [remainingData, stepOffset, amount, amountSize, poolAddress, debtToken, zeroForOne, stepOffset]

    0x00                    // [retSize]
    0x00                    // [retOffset, retSize]
    dup3 0xc4 add           // [argSize, retOffset, retSize]
    0x00                    // [argOffset, argSize, retOffset, retSize]
    0x00                    // [value, argOffset, argSize, retOffset, retSize]
    dup10                   // [to, value, argOffset, argSize, retOffset, retSize]
    0x1388 gas sub
    call



    iszero iszero transfer_step jumpi
    err jump


    // store args in memory
    // address, uint256
    transfer_step:

    __FUNC_SIG(transfer)        // [sig, remainingData, stepOffset, amount, amountSize, poolAddress, debtToken, zeroForOne, stepOffset]
    0x00 mstore                 // [remainingData, stepOffset, amount, amountSize, poolAddress, debtToken, zeroForOne, stepOffset]
    caller 0x20 mstore
    dup3 0x40 mstore


    0x00                        // [ret_size]
    dup1                        // [ret_offset, ret_size]
    0x44                        // [args_size, ret_offset, ret_size]
    0x1c                        // [args_offset, args_size, ret_offset, ret_size]
    dup3                        // [value, args_offset, args_size, ret_offset, ret_size]
    dup11                       // [to, value, args_offset, args_size, ret_offset, ret_size]
    gas                         // [gas, to, value, args_offset, args_size, ret_offset, ret_size]
    call                        // [successs, stepOffset]

    iszero iszero
    uv2eopse_success jumpi
    err jump

    // Resume execution in invoking macro
    uv2eopse_success:


}


#define macro UV2EXACT_OUT_PAY_TO_SELF_INLINE() = takes (0) returns (0) {
    0x022c0d9f 0xe0 shl 0x00 mstore
    dup1 calldataload 0x60 shr                              // [poolAddress, stepOffset]
    dup2 0x14 add calldataload 0xF8 shr                     // [zeroForOne, poolAddress, stepOffset]
    swap1
    dup3 0x15 add calldataload 0xF8 shr                     // [amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x16 add calldataload dup2 0x4 mul 0x100 sub shr   // [amount, amountSize, poolAddress, zeroForOne, stepOffset]

    dup4

    iszero uv2eopsi_Zero_Token_out jumpi
        0x00 0x04 mstore
        dup1 0x24 mstore
        uv2eopsi_continue jump
    uv2eopsi_Zero_Token_out:
        dup1 0x04 mstore
        0x00 0x24 mstore

    uv2eopsi_continue:
    address 0x44 mstore

    dup5                    // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0x80 0x64 mstore        // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    0x00                    // [retSize, stepOffset]
    0x00                    // [retOffset, retSize, stepOffset]
    0xc4                    // [argSize, retOffset, retSize, stepOffset]
    0x00                    // [argOffset, argSize, retOffset, retSize, stepOffset]
    0x00                    // [value, argOffset, argSize, retOffset, retSize, stepOffset]
    dup9                    // [to, argOffset, argSize, retOffset, retSize, stepOffset]
    0x1388 gas sub
    call

    iszero iszero uv2eopsi_success jumpi
    err jump

    // to next step
    // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    uv2eopsi_success:
    0x2 dup4 div dup2 add 0x16 add      // [nextStepOffset, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    swap6                               // [stepOffset, stepOffset, amount, amountSize, poolAddress, zeroForOne, nextStepOffset]
    pop pop pop pop pop pop             // [nextStepOffset]
    dup1 calldataload
    0xE0 shr
    dup1 0x0 eq end jumpi
    nxt jump

}

#define macro UV2EXACT_OUT_PAY_TO_SELF() = takes (0) returns (0) {
    0x022c0d9f 0xe0 shl 0x00 mstore
    dup1 calldataload 0x60 shr                                  // [poolAddress, stepOffset]
    dup2 0x14 add calldataload 0xF8 shr                         // [zeroForOne, poolAddress, stepOffset]
    swap1
    dup3 0x15 add calldataload 0xF8 shr                         // [amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x16 add calldataload dup2 0x4 mul 0x100 sub shr       // [amount, amountSize, poolAddress, zeroForOne, stepOffset]

    dup4
    iszero uv2eops_Zero_Token_out jumpi
        0x00 0x04 mstore
        dup1 0x24 mstore
        uv2eops_cont jump
    uv2eops_Zero_Token_out:
        dup1 0x04 mstore
        0x00 0x24 mstore

    uv2eops_cont:

    address 0x44 mstore
    dup5                                                        // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    0x80 0x64 mstore
    dup1 0x16 add 0x2 dup5 div add calldatasize sub             // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1                                                        // [remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1 0x84 mstore
    dup3 0x16 add 0x2 dup7 div add                              // [stepOffset + dataUsed, remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    0xA4 calldatacopy                                           // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0x00                    // [retSize, stepOffset]
    0x00                    // [retOffset, retSize, stepOffset]
    dup3 0xC4 add           // [argSize, retOffset, retSize, stepOffset]
    0x00                    // [argOffset, argSize, retOffset, retSize, stepOffset]
    0x00                    // [value, argOffset, argSize, retOffset, retSize, stepOffset]
    dup10                   // [to, argOffset, argSize, retOffset, retSize, stepOffset]
    0x1388 gas sub
    call

    iszero iszero uv2eops_success jumpi
    err jump
    // Resume execution in invoking macro
    uv2eops_success:
}


#define macro UV2EXACT_OUT_PAY_TO_NEXT_INLINE() = takes (0) returns (0) {
    0x022c0d9f 0xe0 shl 0x00 mstore
    dup1 calldataload 0x60 shr                              // [poolAddress, stepOffset]
    dup2 0x14 add calldataload 0xF8 shr                     // [zeroForOne, poolAddress, stepOffset]
    swap1
    dup3 0x15 add calldataload 0xF8 shr                     // [amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x16 add calldataload dup2 0x4 mul 0x100 sub shr   // [amount, amountSize, poolAddress, zeroForOne, stepOffset]

    dup4

    iszero uv2eopni_Zero_Token_out jumpi
    0x00 0x04 mstore
        dup1 0x24 mstore
        uv2eopni_continue jump
    uv2eopni_Zero_Token_out:
        dup1 0x04 mstore
        0x00 0x24 mstore

    uv2eopni_continue:

    dup5                                                            // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1 0x16 add 0x2 dup5 div add 0x4 add calldataload 0x60 shr    // [nextPool, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    0x44 mstore
    0x80 0x64 mstore                                                // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0x00                    // [retSize, stepOffset]
    0x00                    // [retOffset, retSize, stepOffset]
    0xc4                    // [argSize, retOffset, retSize, stepOffset]
    0x00                    // [argOffset, argSize, retOffset, retSize, stepOffset]
    0x00                    // [value, argOffset, argSize, retOffset, retSize, stepOffset]
    dup9                    // [to, argOffset, argSize, retOffset, retSize, stepOffset]
    0x1388 gas sub
    call

    iszero iszero uv2eopni_success jumpi
    err jump

    // to next step
    // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    uv2eopni_success:
    0x2 dup4 div dup2 add 0x16 add      // [nextStepOffset, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    swap6                               // [stepOffset, stepOffset, amount, amountSize, poolAddress, zeroForOne, nextStepOffset]
    pop pop pop pop pop pop             // [nextStepOffset]
    dup1 calldataload
    0xE0 shr
    dup1 0x0 eq end jumpi
    nxt jump

}

#define macro UV2EXACT_OUT_PAY_TO_NEXT() = takes (0) returns (0) {
    0x022c0d9f 0xe0 shl 0x00 mstore
    dup1 calldataload 0x60 shr                                  // [poolAddress, stepOffset]
    dup2 0x14 add calldataload 0xF8 shr                         // [zeroForOne, poolAddress, stepOffset]
    swap1
    dup3 0x15 add calldataload 0xF8 shr                         // [amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x16 add calldataload dup2 0x4 mul 0x100 sub shr       // [amount, amountSize, poolAddress, zeroForOne, stepOffset]

    dup4
    iszero uv2eopn_Zero_Token_out jumpi
        0x00 0x04 mstore
        dup1 0x24 mstore
        uv2eopn_cont jump
    uv2eopn_Zero_Token_out:
    dup1 0x04 mstore
    0x00 0x24 mstore

    uv2eopn_cont:


    dup5                                                            // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1 0x16 add 0x2 dup5 div add 0x4 add calldataload 0x60 shr    // [nextPool, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    0x44 mstore

    0x80 0x64 mstore
    dup1 0x16 add 0x2 dup5 div add calldatasize sub             // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1                                                        // [remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1 0x84 mstore
    dup3 0x16 add 0x2 dup7 div add                              // [stepOffset + dataUsed, remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    0xA4 calldatacopy                                           // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0x00                    // [retSize, stepOffset]
    0x00                    // [retOffset, retSize, stepOffset]
    dup3 0xC4 add           // [argSize, retOffset, retSize, stepOffset]
    0x00                    // [argOffset, argSize, retOffset, retSize, stepOffset]
    0x00                    // [value, argOffset, argSize, retOffset, retSize, stepOffset]
    dup10                   // [to, argOffset, argSize, retOffset, retSize, stepOffset]
    0x1388 gas sub
    call

    iszero iszero uv2eopn_success jumpi
    err jump
    // Resume execution in invoking macro
    uv2eopn_success:
}

#define macro UV2EXACT_OUT_PAY_TO_ADDRESS_INLINE() = takes (0) returns (0) {
    0x022c0d9f 0xe0 shl 0x00 mstore
    dup1 calldataload 0x60 shr                              // [poolAddress, stepOffset]
    dup2 0x14 add calldataload 0xF8 shr                     // [zeroForOne, poolAddress, stepOffset]
    swap1
    dup3 0x15 add calldataload 0x60 shr                     // [payToAddress, poolAddress, zeroForOne, stepOffset]
    0x44 mstore
    dup3 0x29 add calldataload 0xF8 shr                     // [amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x2A add calldataload dup2 0x4 mul 0x100 sub shr   // [amount, amountSize, poolAddress, zeroForOne, stepOffset]

    dup4

    iszero uv2eopai_Zero_Token_out jumpi
        0x00 0x04 mstore
        dup1 0x24 mstore
        uv2eopai_continue jump
    uv2eopai_Zero_Token_out:
        dup1 0x04 mstore
        0x00 0x24 mstore

    uv2eopai_continue:

    dup5                    // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    0x80 0x64 mstore        // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0x00                    // [retSize, stepOffset]
    0x00                    // [retOffset, retSize, stepOffset]
    0xc4                    // [argSize, retOffset, retSize, stepOffset]
    0x00                    // [argOffset, argSize, retOffset, retSize, stepOffset]
    0x00                    // [value, argOffset, argSize, retOffset, retSize, stepOffset]
    dup9                    // [to, argOffset, argSize, retOffset, retSize, stepOffset]
    0x1388 gas sub
    call

    iszero iszero uv2eopai_success jumpi
    err jump

    // to next step
    // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    uv2eopai_success:
    0x2 dup4 div dup2 add 0x2A add      // [nextStepOffset, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    swap6                               // [stepOffset, stepOffset, amount, amountSize, poolAddress, zeroForOne, nextStepOffset]
    pop pop pop pop pop pop             // [nextStepOffset]
    dup1 calldataload
    0xE0 shr
    dup1 0x0 eq end jumpi
    nxt jump

}

#define macro UV2EXACT_OUT_PAY_TO_ADDRESS() = takes (0) returns (0) {
    0x022c0d9f 0xe0 shl 0x00 mstore
    dup1 calldataload 0x60 shr                                  // [poolAddress, stepOffset]
    dup2 0x14 add calldataload 0xF8 shr                         // [zeroForOne, poolAddress, stepOffset]
    swap1
    dup3 0x15 add calldataload 0x60 shr                     // [payToAddress, poolAddress, zeroForOne, stepOffset]
    0x44 mstore
    dup3 0x29 add calldataload 0xF8 shr                         // [amountSize, poolAddress, zeroForOne, stepOffset]
    dup4 0x2A add calldataload dup2 0x4 mul 0x100 sub shr       // [amount, amountSize, poolAddress, zeroForOne, stepOffset]

    dup4
    iszero uv2eopa_Zero_Token_out jumpi
        0x00 0x04 mstore
        dup1 0x24 mstore
        uv2eopa_cont jump
    uv2eopa_Zero_Token_out:
        dup1 0x04 mstore
        0x00 0x24 mstore

    uv2eopa_cont:


    dup5                                                        // [stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0x80 0x64 mstore
    dup1 0x2A add 0x2 dup5 div add calldatasize sub             // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1                                                        // [remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    dup1 0x84 mstore
    dup3 0x2A add 0x2 dup7 div add                              // [stepOffset + dataUsed, remainingData, remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]
    0xA4 calldatacopy                                           // [remainingData, stepOffset, amount, amountSize, poolAddress, zeroForOne, stepOffset]

    0x00                    // [retSize, stepOffset]
    0x00                    // [retOffset, retSize, stepOffset]
    dup3 0xC4 add           // [argSize, retOffset, retSize, stepOffset]
    0x00                    // [argOffset, argSize, retOffset, retSize, stepOffset]
    0x00                    // [value, argOffset, argSize, retOffset, retSize, stepOffset]
    dup10                   // [to, argOffset, argSize, retOffset, retSize, stepOffset]
    0x1388 gas sub
    call

    iszero iszero uv2eopa_success jumpi
    err jump
    // Resume execution in invoking macro
    uv2eopa_success:
}



#define macro V3_CALLBACK() = takes (0) returns (0) {
    0x84                // data start offset
    0x84 calldataload
    0xE0 shr
    nxt jump
}

#define macro V2_CALLBACK() = takes (0) returns (0) {
    0xA4                // data start offset
    0xA4 calldataload
    0xE0 shr
    nxt jump
}

#define macro REVERT() = takes(0) returns (0) {
    0x00 0x00 revert
}
#define macro MAIN() = takes (0) returns (0) {


    0x00                    // signifies first place
    0x00 calldataload        // [calldata @ 0x00, 0x48]

    0xE0 shr                 // [func_sig (calldata @ 0x00 >> 0xE0), 0x48]

    dup1 0xfa461e33 eq v3Callback jumpi
    dup1 0x10d1e85c eq v2Callback jumpi
    // solidly
    dup1 0x9a7bff79 eq v2Callback jumpi
    // pancake
    dup1 0x84800812 eq v2Callback jumpi
    // convergence
    dup1 0xdf9aee68 eq v2Callback jumpi
    // saita
    dup1 0xfe1b3a66 eq v2Callback jumpi
    // cro
    dup1 0xffe1ac97 eq v2Callback jumpi
    // elk
    dup1 0x07d3513a eq v2Callback jumpi
    // dxswap
    dup1 0x78b94ae6 eq v2Callback jumpi
    // apeswap
    dup1 0xbecda363 eq v2Callback jumpi
    // unicswap
    dup1 0x8998d6ae eq v2Callback jumpi
    // wiseswap
    dup1 0x84645f79 eq v2Callback jumpi

    nxt jump
    stop
    v3Callback:
        V3_CALLBACK()
        end jump

    v2Callback:
        V2_CALLBACK()
        end jump

    nxt:
        dup1 0x00000600 eq uv3eops jumpi
        dup1 0x00000700 eq uv3eopse jumpi
        dup1 0x00000800 eq uv3eopn jumpi
        dup1 0x00000900 eq uv3eopa jumpi

        dup1 0x00001000 eq uv2eopse jumpi
        dup1 0x00002000 eq uv2eopsei jumpi
        dup1 0x00003000 eq uv2eops jumpi
        dup1 0x00004000 eq uv2eopsi jumpi
        dup1 0x00005000 eq uv2eopa jumpi
        dup1 0x00006000 eq uv2eopai jumpi
        dup1 0x00007000 eq uv2eopn jumpi
        dup1 0x00008000 eq uv2eopni jumpi

        dup1 0x00010000 eq beops jumpi
        dup1 0x00020000 eq beopse jumpi
        dup1 0x00030000 eq beopn jumpi
        dup1 0x00040000 eq beopa jumpi


        dup1 0x00000080 eq ps jumpi
        dup1 0x00000090 eq pa jumpi
        dup1 0x00000010 eq pn jumpi

        dup1 0x00000666 eq br jumpi
        dup1 0x00000001 eq wd jumpi
        dup1 0x00000002 eq ap jumpi

        err jump
        uv3eops:
            dup2 0x04 add
            UV3EXACT_OUT_PAY_TO_SELF()
            0x00 0x00 return
        uv3eopse:
            dup2 0x04 add
            UV3EXACT_OUT_PAY_TO_SENDER()
            0x00 0x00 return
        uv3eopa:
            dup2 0x04 add
            UV3EXACT_OUT_PAY_TO_ADDRESS()
            0x00 0x00 return
        uv3eopn:
            dup2 0x04 add
            UV3EXACT_OUT_PAY_TO_NEXT()
            0x00 0x00 return



        uv2eopa:
            dup2 0x04 add
            UV2EXACT_OUT_PAY_TO_ADDRESS()
            0x00 0x00 return
        uv2eopai:
            dup2 0x04 add
            UV2EXACT_OUT_PAY_TO_ADDRESS_INLINE()
            0x00 0x00 return
        uv2eopn:
            dup2 0x04 add
            UV2EXACT_OUT_PAY_TO_NEXT()
            0x00 0x00 return
        uv2eopni:
            dup2 0x04 add
            UV2EXACT_OUT_PAY_TO_NEXT_INLINE()
            0x00 0x00 return
        uv2eopse:
            dup2 0x04 add
            UV2EXACT_OUT_PAY_TO_SENDER()
            0x00 0x00 return
        uv2eopsei:
            dup2 0x04 add
            UV2EXACT_OUT_PAY_TO_SENDER_INLINE()
            0x00 0x00 return
        uv2eops:
            dup2 0x04 add
            UV2EXACT_OUT_PAY_TO_SELF()
            0x00 0x00 return
        uv2eopsi:
            dup2 0x04 add
            UV2EXACT_OUT_PAY_TO_SELF_INLINE()
            0x00 0x00 return



        beopse:
            dup2 0x04 add
            BALANCER_EXACT_OUT_PAY_TO_SENDER()
            0x00 0x00 return
        beops:
            dup2 0x04 add
            BALANCER_EXACT_OUT_PAY_TO_SELF()
            0x00 0x00 return
        beopa:
            dup2 0x04 add
            BALANCER_EXACT_OUT_PAY_TO_ADDRESS()
            0x00 0x00 return
        beopn:
            dup2 0x04 add
            BALANCER_EXACT_OUT_PAY_TO_NEXT()
            0x00 0x00 return


        ps:
            dup2 0x04 add
            PAY_SENDER()
            0x00 0x00 return
        pn:
            dup2 0x04 add
            PAY_NEXT()
            0x00 0x00 return
        pa:
            dup2 0x04 add
            PAY_ADDRESS()
            0x00 0x00 return

        br:
            dup2 0x04 add
            PAY_BRIBE()
            0x00 0x00 return

        wd:
            WITHDRAW()
            0x00 0x00 return
        ap:
            APPROVE()
            0x00 0x00 return
    err jump

    err:
        REVERT()
        stop
    end:
}
